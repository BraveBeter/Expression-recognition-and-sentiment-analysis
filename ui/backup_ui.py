# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'new_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


# 时间记录
import time
import tkinter
import traceback
from statistics import mode
from tkinter import messagebox
from collections import Counter
# 图像处理
import cv2
import matplotlib.pyplot as plt
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as functional
from matplotlib.ticker import FuncFormatter

# 界面
from PyQt5.QtWidgets import QMainWindow, QSystemTrayIcon, QMenu, QAction, QDialog, QVBoxLayout, QMessageBox
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import *
from PyQt5.QtCore import *
import QSwitchButton
from ProgressLabel import ProgressBarLabel
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

"""
面部表情处理部分
"""



# 人脸数据归一化,将像素值从0-255映射到0-1之间
def preprocess_input(images):
    """ preprocess input by substracting the train mean
    # Arguments: images or image of any shape
    # Returns: images or image with substracted train mean (129)
    """
    images = images / 255.0
    return images


def gaussian_weights_init(m):
    classname = m.__class__.__name__
    # 字符串查找find，找不到返回-1，不等-1即字符串中含有该字符
    if classname.find('Conv') != -1:
        m.weight.data.normal_(0.0, 0.04)


class FaceCNN(nn.Module):
    # 初始化网络结构
    def __init__(self):
        super(FaceCNN, self).__init__()

        # 第一次卷积、池化
        self.conv1 = nn.Sequential(
            nn.Conv2d(in_channels=1, out_channels=64, kernel_size=3, stride=1, padding=1),  # 卷积层
            nn.BatchNorm2d(num_features=64),  # 归一化
            nn.RReLU(inplace=True),  # 激活函数
            nn.MaxPool2d(kernel_size=2, stride=2),  # 最大值池化
        )

        # 第二次卷积、池化
        self.conv2 = nn.Sequential(
            nn.Conv2d(in_channels=64, out_channels=128, kernel_size=3, stride=1, padding=1),
            nn.BatchNorm2d(num_features=128),
            nn.RReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2, stride=2),
        )

        # 第三次卷积、池化
        self.conv3 = nn.Sequential(
            nn.Conv2d(in_channels=128, out_channels=256, kernel_size=3, stride=1, padding=1),
            nn.BatchNorm2d(num_features=256),
            nn.RReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2, stride=2),
        )

        # 参数初始化
        self.conv1.apply(gaussian_weights_init)
        self.conv2.apply(gaussian_weights_init)
        self.conv3.apply(gaussian_weights_init)

        # 全连接层
        self.fc = nn.Sequential(
            nn.Dropout(p=0.2),
            nn.Linear(in_features=256 * 6 * 6, out_features=4096),
            nn.RReLU(inplace=True),
            nn.Dropout(p=0.5),
            nn.Linear(in_features=4096, out_features=1024),
            nn.RReLU(inplace=True),
            nn.Linear(in_features=1024, out_features=256),
            nn.RReLU(inplace=True),
            nn.Linear(in_features=256, out_features=8),
        )

    # 前向传播
    def forward(self, x):
        x = self.conv1(x)
        x = self.conv2(x)
        x = self.conv3(x)
        # 数据扁平化
        x = x.view(x.shape[0], -1)
        y = self.fc(x)
        return y


# opencv自带的一个面部识别分类器
detection_model_path = '../model/haarcascade_frontalface_alt.xml'
classification_model_path = '../model/model_cnn7.pkl'

# 加载人脸检测模型
face_detection = cv2.CascadeClassifier(detection_model_path)

# 加载表情识别模型
emotion_classifier = torch.load(classification_model_path)

frame_window = 10

# 表情标签
emotion_labels = {0: 'angry', 1: 'disgust', 2: 'fear', 3: 'happy', 4: 'neutral', 5: 'sad', 6: 'surprise', 7: 'tired'}
emotion_num = ('angry', 'disgust', 'fear', 'happy', 'neutral', 'sad', 'surprise', 'tired')
emotion_window = []

font = cv2.FONT_HERSHEY_SIMPLEX

# 表情时间记录
emotion_count = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0}
emotion_start_time = 0
emotion_total_duration = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0}
open_time = 0
flag_time = False
last_time = []
sum_time = 0
plt.rcParams['font.sans-serif'] = ['SimHei']  # 画图做准备
plt.rcParams['axes.unicode_minus'] = False
plt.rcParams['toolbar'] = 'None'
cnt = 0
cnt1 = 0
arr = 20 * [-1]

def sort_emotions(img, set_time, flag):
    global emotion_count
    global emotion_start_time
    global open_time
    global emotion_total_duration
    global flag_time
    global last_time
    global sum_time
    global arr
    global cnt
    global cnt1

    probabilities_array = None  # 在函数开始时初始化为None

    # 读取一帧
    frame = img
    frame = frame[:, ::-1, :]  # 水平翻转，符合自拍习惯
    frame = frame.copy()
    # 获得灰度图，并且在内存中创建一个图像对象
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # 获取当前帧中的全部人脸
    faces = face_detection.detectMultiScale(gray, 1.3, 5)
    # 对于所有发现的人脸
    for (x, y, w, h) in faces:
        # 在脸周围画一个矩形框，(255,0,0)是颜色，2是线宽
        cv2.rectangle(frame, (x, y), (x + w, y + h), (84, 255, 159), 2)

        # 获取人脸图像
        face = gray[y:y + h, x:x + w]

        try:
            # shape变为(48,48)
            face = cv2.resize(face, (48, 48))
        except:
            continue

        # 扩充维度，shape变为(1,48,48,1)
        # 将（1，48，48，1）转换成为(1,1,48,48)
        face = np.expand_dims(face, 0)
        face = np.expand_dims(face, 0)

        # 人脸数据归一化，将像素值从0-255映射到0-1之间
        face = preprocess_input(face)
        new_face = torch.from_numpy(face)
        new_new_face = new_face.float().requires_grad_(False)

        # 调用我们训练好的表情识别模型，预测分类
        emotion_arg = np.argmax(emotion_classifier.forward(new_new_face).detach().numpy())
        # emotion = emotion_labels[emotion_arg]
        emotion = emotion_arg
        output = emotion_classifier.forward(new_new_face)
        # softmax将模型的原始输出转换为表示每个类别概率
        probabilities = functional.softmax(output, dim=1)
        probabilities_array = probabilities.detach().numpy()

        emotion_window.append(emotion)
        emotion_count[emotion_arg] += 1

        if len(emotion_window) >= frame_window:
            emotion_window.pop(0)
            # emotion_mode = Counter(emotion_count).most_common(1)[0][0]
            try:
                # 获得出现次数最多的分类
                emotion_mode = mode(emotion_window)
            except:
                continue
            # 情绪窗口更新时计算持续时间
            if emotion_start_time != 0:
                duration = time.perf_counter() - emotion_start_time
                emotion_total_duration[emotion_mode] += duration
                open_time += duration
                if emotion_mode == 7:  # 疲惫状态
                    # print(ui.switchButton_tired_opener.state)
                    cnt1 += 1
                    arr[cnt] = 1
                    cnt += 1
                    print("\n rate:", float(cnt1 / cnt))
                    print("cnt  cnt1", cnt, cnt1)
                    if cnt == 20:
                        if float(cnt1 / cnt) > 0.75 and ui.switchButton_tired_opener.state:
                            tip1()
                            cnt = 0
                            cnt1 = 0
                            continue
                        v = arr[0]
                        for i in range(0, 19):
                            arr[i] = arr[i + 1]
                        if (v == 1):
                            cnt1 -= 1
                        cnt -= 1
                else:
                    arr[cnt] = 0
                    cnt += 1
                    print("cnt  cnt1", cnt, cnt1)
                    print("\n rate:", float(cnt1 / cnt))
                    if cnt == 20:
                        if float(cnt1 / cnt) > 0.75 and ui.switchButton_tired_opener.state:
                            tip1()
                            cnt = 0
                            cnt1 = 0
                            continue
                        v = arr[0]
                        for i in range(0, 19):
                            arr[i] = arr[i + 1]
                        if (v == 1):
                            cnt1 -= 1
                        cnt -= 1

            emotion_start_time = time.perf_counter()  # 记录当前时间作为情绪开始时间。
            # 这行代码将当前的性能计数器值（即当前时间）赋值给`emotion_start_time`变量，以便后续用于计算情绪持续时间。
            if not flag_time and info_mess(int(ui.spinBox_rest_inform.value()) * 60, open_time, flag):  # 如果时间达到预期时间
                open_time = 0  # 记时变量归0
                flag_time = True  # 表示已经该休息了
            elif flag_time and ui.switchButton_Pomodoro_Technique.state:
                if open_time >= int(ui.spinBox_Pomodoro_Technique.value()) * 60:
                    tip3()
                    flag_time = False
                    open_time = 0
            else:
                pass
        try:
            # 获得出现次数最多的分类
            emotion_mode = mode(emotion_window)
        except:
            continue

        # 在矩形框上部，输出分类文字
        cv2.putText(frame, emotion_labels[emotion_mode], (x, y - 30), font, .9, (0, 0, 255), 1, cv2.LINE_AA)

    try:
        # 将图片从内存中显示到屏幕上
        return frame, probabilities_array
    except:
        traceback.print_exc()
        return img, None


"""
图像界面部分
"""


# 检查数据中的最大值，并决定纵轴的单位
def determine_unit(data):
    max_duration = max(data)
    if max_duration >= 3600:  # 如果最大持续时间超过或等于1小时
        return 'hours', 3600
    elif max_duration >= 60:  # 如果最大持续时间超过或等于1分钟
        return 'minutes', 60
    else:
        return 'seconds', 1


# 根据单位格式化纵轴标签
def format_axis_labels(ax, unit, unit_factor):
    if unit == 'hours':
        ax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f'{x:.2f}小时'))
    elif unit == 'minutes':
        ax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f'{x:.2f}分钟'))
    else:
        ax.yaxis.set_major_formatter(FuncFormatter(lambda x, pos: f'{x:.2f}秒'))


class ChartDialog(QDialog):
    def __init__(self, data, labels, parent=None):
        super(ChartDialog, self).__init__(parent)
        self.unit, self.unit_factor = determine_unit(data)
        self.setWindowTitle('Emotion Duration Chart')
        self.setupUi(data, labels)

    def setupUi(self, data, labels):
        fig, ax = plt.subplots()
        ax.bar(labels, [d / self.unit_factor for d in data])  # 转换数据到正确的单位
        format_axis_labels(ax, self.unit, self.unit_factor)  # 设置纵轴标签格式
        canvas = FigureCanvas(fig)

        layout = QVBoxLayout()
        layout.addWidget(canvas)
        self.setLayout(layout)


def read_Settings():
    # 设置文件路径
    settings_file_path = '../asset/settings.txt'
    settings = {}
    with open(settings_file_path, 'r') as file:
        for line in file:
            if line.strip() and not line.strip().startswith('#'):  # 忽略空行和注释行
                key, value = line.strip().split('=')
                settings[key] = value
    return settings


def getDatabaseConnection():
    import pymysql
    conn = pymysql.connect(host="127.0.0.1", database="facial-emotions", user=user, password=password,
                           charset='utf8')
    return conn


def showWeek():
    conn = getDatabaseConnection()
    cursor = conn.cursor()
    sql = ("SELECT SUM(`angry`) AS `total_angry`,"
           "SUM(`disgust`) AS `total_disgust`,"
           "SUM(`fear`) AS `total_fear`,"
           "SUM(`happy`) AS `total_happy`,"
           "SUM(`neutral`) AS `total_neutral`,"
           "SUM(`sad`) AS `total_sad`,"
           "SUM(`surprise`) AS `total_surprise`,"
           "SUM(`tired`) AS `total_tired`"
           "FROM `emotions_duration`"
           "WHERE `rectime` >= NOW() - INTERVAL 7 DAY")
    try:
        cursor.execute(sql)
    except:
        conn.rollback()

    conn.close()
    cursor.close()


class MyWindow(QMainWindow):
    def __init__(self, parent=None):
        super(MyWindow, self).__init__(parent)
        self.settings = None
        self.setupUi()

    def setupUi(self):
        self.setObjectName("Form")
        self.setFixedSize(777, 466)

        self.settings = read_Settings()

        self.CAM_NUM = 0
        self.cap = cv2.VideoCapture()
        # 在label中播放视频
        self.init_timer()

        self.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.stackedWidget = QtWidgets.QStackedWidget(self)
        self.stackedWidget.setGeometry(QtCore.QRect(-1, 60, 781, 411))
        self.stackedWidget.setStyleSheet("background-color: rgb(240, 240, 240);")
        self.stackedWidget.setObjectName("stackedWidget")
        self.page_monitor = QtWidgets.QWidget()
        self.page_monitor.setObjectName("page_monitor")
        self.label_screen = QtWidgets.QLabel(self.page_monitor)
        self.label_screen.setGeometry(QtCore.QRect(20, 10, 481, 331))
        self.label_screen.setStyleSheet("background-color: rgb(0, 0, 0);")
        self.label_screen.setObjectName("label_screen")
        self.pushButton_monitor = QtWidgets.QPushButton(self.page_monitor)
        self.pushButton_monitor.setGeometry(QtCore.QRect(20, 360, 150, 30))
        self.pushButton_monitor.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.pushButton_monitor.setObjectName("pushButton_monitor")
        # 开启摄像头
        self.pushButton_monitor.clicked.connect(self.open_camera)

        self.pushButton_report = QtWidgets.QPushButton(self.page_monitor)
        self.pushButton_report.setGeometry(QtCore.QRect(220, 360, 150, 30))
        self.pushButton_report.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.pushButton_report.setObjectName("pushButton_report")
        self.pushButton_report.clicked.connect(self.showTotalTime)

        # emotion_labels
        self.Layout_widget = QtWidgets.QWidget(self.page_monitor)
        self.Layout_widget.setGeometry(QtCore.QRect(519, 10, 241, 331))
        self.Layout_widget.setObjectName("Layout_widget")
        self.widget = QtWidgets.QWidget(self.Layout_widget)
        self.widget.setGeometry(QtCore.QRect(0, 0, 241, 331))
        self.widget.setObjectName("widget")
        self.gridLayout_emotions = QtWidgets.QGridLayout(self.widget)
        self.gridLayout_emotions.setContentsMargins(0, 10, 0, 10)
        self.gridLayout_emotions.setVerticalSpacing(20)
        self.gridLayout_emotions.setObjectName("gridLayout_emotions")
        self.progresslabel_sad = ProgressBarLabel(self.widget)
        self.progresslabel_sad.setStyleSheet("background-color: rgb(215, 215, 215);")
        self.progresslabel_sad.setProgress(0)
        self.progresslabel_sad.setObjectName("progresslabel_sad")
        self.gridLayout_emotions.addWidget(self.progresslabel_sad, 5, 1, 1, 1)
        self.label_happy = QtWidgets.QLabel(self.widget)
        self.label_happy.setAlignment(QtCore.Qt.AlignCenter)
        self.label_happy.setObjectName("label_happy")
        self.gridLayout_emotions.addWidget(self.label_happy, 3, 0, 1, 1)
        self.label_disgust = QtWidgets.QLabel(self.widget)
        self.label_disgust.setAlignment(QtCore.Qt.AlignCenter)
        self.label_disgust.setObjectName("label_disgust")
        self.gridLayout_emotions.addWidget(self.label_disgust, 1, 0, 1, 1)
        self.label_neutral = QtWidgets.QLabel(self.widget)
        self.label_neutral.setAlignment(QtCore.Qt.AlignCenter)
        self.label_neutral.setObjectName("label_neutral")
        self.gridLayout_emotions.addWidget(self.label_neutral, 4, 0, 1, 1)
        self.label_fear = QtWidgets.QLabel(self.widget)
        self.label_fear.setAlignment(QtCore.Qt.AlignCenter)
        self.label_fear.setObjectName("label_fear")
        self.gridLayout_emotions.addWidget(self.label_fear, 2, 0, 1, 1)
        self.valuelabel_happy = QtWidgets.QLabel(self.widget)
        self.valuelabel_happy.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.valuelabel_happy.setObjectName("valuelabel_happy")
        self.gridLayout_emotions.addWidget(self.valuelabel_happy, 3, 2, 1, 1)
        self.valuelabel_sad = QtWidgets.QLabel(self.widget)
        self.valuelabel_sad.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.valuelabel_sad.setObjectName("valuelabel_sad")
        self.gridLayout_emotions.addWidget(self.valuelabel_sad, 5, 2, 1, 1)
        self.label_sad = QtWidgets.QLabel(self.widget)
        self.label_sad.setAlignment(QtCore.Qt.AlignCenter)
        self.label_sad.setObjectName("label_sad")
        self.gridLayout_emotions.addWidget(self.label_sad, 5, 0, 1, 1)
        self.progresslabel_disgust = ProgressBarLabel(self.widget)
        self.progresslabel_disgust.setStyleSheet("background-color: rgb(215, 215, 215);")
        self.progresslabel_disgust.setProgress(0)
        self.progresslabel_disgust.setObjectName("progresslabel_disgust")
        self.gridLayout_emotions.addWidget(self.progresslabel_disgust, 1, 1, 1, 1)
        self.valuelabel_fear = QtWidgets.QLabel(self.widget)
        self.valuelabel_fear.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.valuelabel_fear.setObjectName("valuelabel_fear")
        self.gridLayout_emotions.addWidget(self.valuelabel_fear, 2, 2, 1, 1)
        self.progresslabel_neutral = ProgressBarLabel(self.widget)
        self.progresslabel_neutral.setStyleSheet("background-color: rgb(215, 215, 215);")
        self.progresslabel_neutral.setProgress(0)
        self.progresslabel_neutral.setObjectName("progresslabel_neutral")
        self.gridLayout_emotions.addWidget(self.progresslabel_neutral, 4, 1, 1, 1)
        self.valuelabel_disgust = QtWidgets.QLabel(self.widget)
        self.valuelabel_disgust.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.valuelabel_disgust.setObjectName("valuelabel_disgust")
        self.gridLayout_emotions.addWidget(self.valuelabel_disgust, 1, 2, 1, 1)
        self.progresslabel_tired = ProgressBarLabel(self.widget)
        self.progresslabel_tired.setStyleSheet("background-color: rgb(215, 215, 215);")
        self.progresslabel_tired.setProgress(0)
        self.progresslabel_tired.setObjectName("progresslabel_tired")
        self.gridLayout_emotions.addWidget(self.progresslabel_tired, 7, 1, 1, 1)
        self.label_surprise = QtWidgets.QLabel(self.widget)
        self.label_surprise.setAlignment(QtCore.Qt.AlignCenter)
        self.label_surprise.setObjectName("label_surprise")
        self.gridLayout_emotions.addWidget(self.label_surprise, 6, 0, 1, 1)
        self.valuelabel_angry = QtWidgets.QLabel(self.widget)
        self.valuelabel_angry.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.valuelabel_angry.setObjectName("valuelabel_angry")
        self.gridLayout_emotions.addWidget(self.valuelabel_angry, 0, 2, 1, 1)
        self.valuelabel_surprise = QtWidgets.QLabel(self.widget)
        self.valuelabel_surprise.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.valuelabel_surprise.setObjectName("valuelabel_surprise")
        self.gridLayout_emotions.addWidget(self.valuelabel_surprise, 6, 2, 1, 1)
        self.progresslabel_surprise = ProgressBarLabel(self.widget)
        self.progresslabel_surprise.setStyleSheet("background-color: rgb(215, 215, 215);")
        self.progresslabel_surprise.setProgress(0)
        self.progresslabel_surprise.setObjectName("progresslabel_surprise")
        self.gridLayout_emotions.addWidget(self.progresslabel_surprise, 6, 1, 1, 1)
        self.valuelabel_tired = QtWidgets.QLabel(self.widget)
        self.valuelabel_tired.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.valuelabel_tired.setObjectName("valuelabel_tired")
        self.gridLayout_emotions.addWidget(self.valuelabel_tired, 7, 2, 1, 1)
        self.label_tired = QtWidgets.QLabel(self.widget)
        self.label_tired.setAlignment(QtCore.Qt.AlignCenter)
        self.label_tired.setObjectName("label_tired")
        self.gridLayout_emotions.addWidget(self.label_tired, 7, 0, 1, 1)
        self.progresslabel_happy = ProgressBarLabel(self.widget)
        self.progresslabel_happy.setStyleSheet("background-color: rgb(215, 215, 215);")
        self.progresslabel_happy.setProgress(0)
        self.progresslabel_happy.setObjectName("progresslabel_happy")
        self.gridLayout_emotions.addWidget(self.progresslabel_happy, 3, 1, 1, 1)
        self.progresslabel_angry = ProgressBarLabel(self.widget)
        self.progresslabel_angry.setStyleSheet("background-color: rgb(215, 215, 215);")
        self.progresslabel_angry.setProgress(0)
        self.progresslabel_angry.setObjectName("progresslabel_angry")
        self.gridLayout_emotions.addWidget(self.progresslabel_angry, 0, 1, 1, 1)
        self.progresslabel_fear = ProgressBarLabel(self.widget)
        self.progresslabel_fear.setStyleSheet("background-color: rgb(215, 215, 215);")
        self.progresslabel_fear.setProgress(0)
        self.progresslabel_fear.setObjectName("progresslabel_fear")
        self.gridLayout_emotions.addWidget(self.progresslabel_fear, 2, 1, 1, 1)
        self.valuelabel_neutral = QtWidgets.QLabel(self.widget)
        self.valuelabel_neutral.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.valuelabel_neutral.setObjectName("valuelabel_neutral")
        self.gridLayout_emotions.addWidget(self.valuelabel_neutral, 4, 2, 1, 1)
        self.label_angry = QtWidgets.QLabel(self.widget)
        self.label_angry.setEnabled(True)
        self.label_angry.setAlignment(QtCore.Qt.AlignCenter)
        self.label_angry.setObjectName("label_angry")
        self.gridLayout_emotions.addWidget(self.label_angry, 0, 0, 1, 1)
        self.gridLayout_emotions.setColumnStretch(0, 1)
        self.gridLayout_emotions.setColumnStretch(1, 3)
        self.gridLayout_emotions.setColumnStretch(2, 1)

        self.stackedWidget.addWidget(self.page_monitor)

        # 设置界面
        self.page_settings = QtWidgets.QWidget()
        self.page_settings.setObjectName("page_settings")
        self.widget = QtWidgets.QWidget(self.page_settings)
        self.widget.setGeometry(QtCore.QRect(20, 10, 741, 141))
        self.widget.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.widget.setObjectName("widget")
        self.label_rest = QtWidgets.QLabel(self.widget)
        self.label_rest.setGeometry(QtCore.QRect(10, 10, 91, 31))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        self.label_rest.setFont(font)
        self.label_rest.setObjectName("label_rest")
        self.label_rest_opener = QtWidgets.QLabel(self.widget)
        self.label_rest_opener.setGeometry(QtCore.QRect(10, 60, 100, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.label_rest_opener.setFont(font)
        self.label_rest_opener.setObjectName("label_rest_opener")
        self.label_Pomodoro_Technique = QtWidgets.QLabel(self.widget)
        self.label_Pomodoro_Technique.setGeometry(QtCore.QRect(10, 100, 100, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.label_Pomodoro_Technique.setFont(font)
        self.label_Pomodoro_Technique.setObjectName("label_Pomodoro_Technique")
        self.spinBox_rest_inform = QtWidgets.QSpinBox(self.widget)
        self.spinBox_rest_inform.setGeometry(QtCore.QRect(270, 60, 80, 25))
        self.spinBox_rest_inform.setObjectName("spinBox_rest_inform")
        self.spinBox_rest_inform.setValue(int(self.settings['Notice_interval_time']))

        self.spinBox_Pomodoro_Technique = QtWidgets.QSpinBox(self.widget)
        self.spinBox_Pomodoro_Technique.setGeometry(QtCore.QRect(270, 100, 80, 25))
        self.spinBox_Pomodoro_Technique.setObjectName("spinBox_Pomodoro_Technique")
        self.spinBox_Pomodoro_Technique.setValue(int(self.settings['Learning_interval_time']))

        self.label_rest_inform = QtWidgets.QLabel(self.widget)
        self.label_rest_inform.setGeometry(QtCore.QRect(360, 60, 120, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.label_rest_inform.setFont(font)
        self.label_rest_inform.setObjectName("label_rest_inform")
        self.label_Pomodoro_Technique_2 = QtWidgets.QLabel(self.widget)
        self.label_Pomodoro_Technique_2.setGeometry(QtCore.QRect(360, 100, 120, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.label_Pomodoro_Technique_2.setFont(font)
        self.label_Pomodoro_Technique_2.setObjectName("label_Pomodoro_Technique_2")

        self.switchButton_Pomodoro_Technique = QSwitchButton.SwitchButton(self.widget)
        self.switchButton_Pomodoro_Technique.setGeometry(QtCore.QRect(110, 103, 50, 26))
        self.switchButton_Pomodoro_Technique.setObjectName("comboBox_Pomodoro_Technique")
        self.switchButton_Pomodoro_Technique.mousePressEvent = self.enable_Pomodoro_Technique_spinBox
        if (self.settings['Pomodoro_Technique'] == "ON"):
            self.switchButton_Pomodoro_Technique.state = True
        else:
            self.spinBox_Pomodoro_Technique.setEnabled(False)

        self.switchButton_rest_opener = QSwitchButton.SwitchButton(self.widget)
        self.switchButton_rest_opener.setGeometry(QtCore.QRect(110, 63, 50, 26))
        self.switchButton_rest_opener.setObjectName("comboBox_rest_opener")
        self.switchButton_rest_opener.mousePressEvent = self.enable_rest_spinBox
        if (self.settings['Notification_switch'] == "ON"):
            self.switchButton_rest_opener.state = True
            self.switchButton_Pomodoro_Technique.setEnabled(True)
        else:
            self.spinBox_rest_inform.setEnabled(False)
            self.switchButton_Pomodoro_Technique.setEnabled(False)

        self.widget_2 = QtWidgets.QWidget(self.page_settings)
        self.widget_2.setGeometry(QtCore.QRect(20, 160, 741, 101))
        self.widget_2.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.widget_2.setObjectName("widget_2")
        self.label_rest_4 = QtWidgets.QLabel(self.widget_2)
        self.label_rest_4.setGeometry(QtCore.QRect(10, 10, 91, 31))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        self.label_rest_4.setFont(font)
        self.label_rest_4.setObjectName("label_rest_4")
        self.label_tired_opener = QtWidgets.QLabel(self.widget_2)
        self.label_tired_opener.setGeometry(QtCore.QRect(10, 60, 100, 30))
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.label_tired_opener.setFont(font)
        self.label_tired_opener.setObjectName("label_tired_opener")
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.switchButton_tired_opener = QSwitchButton.SwitchButton(self.widget_2)
        self.switchButton_tired_opener.setGeometry(QtCore.QRect(110, 62, 50, 26))
        self.switchButton_tired_opener.setObjectName("comboBox_tired_opener")
        self.switchButton_tired_opener.mousePressEvent = self.enable_tired_spinBox
        if (self.settings['alert_switch'] == "ON"):
            self.switchButton_tired_opener.state = True

        self.pushButton_save = QtWidgets.QPushButton(self.page_settings)
        self.pushButton_save.setGeometry(QtCore.QRect(660, 360, 93, 31))
        self.pushButton_save.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.pushButton_save.clicked.connect(self.save_settings)
        self.pushButton_save.setObjectName("pushButton_save")
        self.widget_3 = QtWidgets.QWidget(self.page_settings)
        self.widget_3.setGeometry(QtCore.QRect(20, 270, 741, 81))
        self.widget_3.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.widget_3.setObjectName("widget_3")
        self.label_exit = QtWidgets.QLabel(self.widget_3)
        self.label_exit.setGeometry(QtCore.QRect(10, 10, 91, 31))
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(12)
        self.label_exit.setFont(font)
        self.label_exit.setObjectName("label_exit")
        self.layoutWidget1 = QtWidgets.QWidget(self.widget_3)
        self.layoutWidget1.setGeometry(QtCore.QRect(10, 50, 312, 25))
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.gridLayout = QtWidgets.QGridLayout(self.layoutWidget1)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")
        self.label = QtWidgets.QLabel(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.radioButton_direct = QtWidgets.QRadioButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.radioButton_direct.setFont(font)
        self.radioButton_direct.setObjectName("radioButton_direct")
        if (self.settings['Exit'] == "0"):
            self.radioButton_direct.setChecked(True)

        self.gridLayout.addWidget(self.radioButton_direct, 0, 1, 1, 1)
        self.radioButton_min = QtWidgets.QRadioButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(10)
        self.radioButton_min.setFont(font)
        self.radioButton_min.setObjectName("radioButton_min")
        if (self.settings['Exit'] == "1"):
            self.radioButton_min.setChecked(True)

        self.gridLayout.addWidget(self.radioButton_min, 0, 2, 1, 1)
        self.stackedWidget.addWidget(self.page_settings)
        self.layoutWidget2 = QtWidgets.QWidget(self)
        self.layoutWidget2.setGeometry(QtCore.QRect(0, 0, 304, 61))
        self.layoutWidget2.setObjectName("layoutWidget2")
        self.gridLayout_bar = QtWidgets.QGridLayout(self.layoutWidget2)
        self.gridLayout_bar.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_bar.setSpacing(0)
        self.gridLayout_bar.setObjectName("gridLayout_bar")
        self.label_monitor = QtWidgets.QLabel(self.layoutWidget2)
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(16)
        font.setBold(False)
        font.setWeight(50)
        self.label_monitor.setFont(font)
        self.label_monitor.setAlignment(QtCore.Qt.AlignCenter)
        self.label_monitor.setStyleSheet("background-color: rgb(240, 240, 240);")
        self.label_monitor.setObjectName("label_monitor")
        # 点击跳转主界面
        self.label_monitor.mousePressEvent = self.labelClicked_0
        self.gridLayout_bar.addWidget(self.label_monitor, 0, 0, 1, 1)
        self.label_inform = QtWidgets.QLabel(self.layoutWidget2)
        font = QtGui.QFont()
        font.setFamily("黑体")
        font.setPointSize(16)
        self.label_inform.setFont(font)
        self.label_inform.setAlignment(QtCore.Qt.AlignCenter)
        self.label_inform.setObjectName("label_inform")
        # 点击跳转设置界面
        self.label_inform.mousePressEvent = self.labelClicked_1
        self.gridLayout_bar.addWidget(self.label_inform, 0, 1, 1, 1)

        # 创建系统托盘图标
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(QIcon('icon.png'))  # 设置托盘图标

        # 创建托盘菜单（可选）
        self.tray_menu = QMenu(self)
        self.quit_action = QAction('退出', self)
        self.tray_menu.addAction(self.quit_action)
        self.quit_action.triggered.connect(self.quit)

        self.tray_icon.setContextMenu(self.tray_menu)
        self.tray_icon.activated.connect(self.iconActivated)  # 连接信号
        self.tray_icon.show()

        self.retranslateUi(self)
        QtCore.QMetaObject.connectSlotsByName(self)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.pushButton_monitor.setText(_translate("Form", "开始监测"))
        self.pushButton_report.setText(_translate("Form", "生成监测报告"))
        self.label_happy.setText(_translate("Form", "高兴"))
        self.label_disgust.setText(_translate("Form", "厌恶"))
        self.label_neutral.setText(_translate("Form", "中立"))
        self.label_fear.setText(_translate("Form", "害怕"))
        self.valuelabel_happy.setText(_translate("Form", "0.0%"))
        self.valuelabel_sad.setText(_translate("Form", "0.0%"))
        self.label_sad.setText(_translate("Form", "伤心"))
        self.valuelabel_fear.setText(_translate("Form", "0.0%"))
        self.valuelabel_disgust.setText(_translate("Form", "0.0%"))
        self.label_surprise.setText(_translate("Form", "惊讶"))
        self.valuelabel_angry.setText(_translate("Form", "0.0%"))
        self.valuelabel_surprise.setText(_translate("Form", "0.0%"))
        self.valuelabel_tired.setText(_translate("Form", "0.0%"))
        self.label_tired.setText(_translate("Form", "疲惫"))
        self.valuelabel_neutral.setText(_translate("Form", "0.0%"))
        self.label_angry.setText(_translate("Form", "生气"))
        self.label_rest.setText(_translate("Form", "休息提醒"))
        self.label_rest_opener.setText(_translate("Form", "休息通知开关"))
        self.label_Pomodoro_Technique.setText(_translate("Form", "工作通知开关"))
        self.label_rest_inform.setText(_translate("Form", "分钟提醒一次"))
        self.label_Pomodoro_Technique_2.setText(_translate("Form", "分钟提醒一次"))
        self.label_rest_4.setText(_translate("Form", "疲惫提醒"))
        self.label_tired_opener.setText(_translate("Form", "通知开关"))
        self.pushButton_save.setText(_translate("Form", "保存"))
        self.label_exit.setText(_translate("Form", "退出设置"))
        self.label.setText(_translate("Form", "退出时："))
        self.radioButton_direct.setText(_translate("Form", "直接退出"))
        self.radioButton_min.setText(_translate("Form", "最小化到托盘"))
        self.label_monitor.setText(_translate("Form", "状态监测"))
        self.label_inform.setText(_translate("Form", "提醒设置"))

    def labelClicked_0(self, event):
        # 这里切换到第一个页面，index 为 0
        self.stackedWidget.setCurrentIndex(0)
        self.label_monitor.setStyleSheet("background-color: rgb(240, 240, 240);")
        self.label_inform.setStyleSheet("background-color: rgb(255, 255, 255);")

    def labelClicked_1(self, event):
        # 这里切换到第二个页面，index 为 1
        self.stackedWidget.setCurrentIndex(1)
        self.label_monitor.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_inform.setStyleSheet("background-color: rgb(240, 240, 240);")

    def open_camera(self):
        # 检测该设备是否能打开
        flag = self.cap.open(0)
        if flag is False:
            QMessageBox.critical(self, "错误", "无法打开摄像头。")
            return
        else:
            if self.pushButton_monitor.text() == '开始监测':
                # 幕布可以播放
                self.label_screen.setEnabled(True)
                # 打开摄像头按钮变为关闭摄像头
                self.pushButton_monitor.setText("结束监测")
                self.timer.start()
            else:
                self.pushButton_monitor.setText("开始监测")
                # 创建一个黑色的QPixmap对象，大小和label_screen一致
                blackPixmap = QPixmap(self.label_screen.width(), self.label_screen.height())
                blackPixmap.fill(Qt.black)
                # 使用setPixmap方法将label_screen设置为黑色
                self.label_screen.setPixmap(blackPixmap)
                self.cap.release()
                self.timer.stop()
                print(emotion_total_duration)
                self.init_progressbar()

    # 播放视频画面
    def init_timer(self):
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.show_pic)

    # 显示视频图像
    def show_pic(self):
        ret, img = self.cap.read()
        if ret:
            img, probabilities_array = sort_emotions(img, self.settings['Notice_interval_time'],
                                                     self.switchButton_rest_opener.state)
            cur_frame = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            # 视频流的长和宽
            height, width = cur_frame.shape[:2]
            pixmap = QImage(cur_frame, width, height, QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(pixmap)
            # 获取是视频流和label窗口的长宽比值的最大值，适应label窗口播放，不然显示不全
            ratio = max(width / self.label_screen.width(), height / self.label_screen.height())
            pixmap.setDevicePixelRatio(ratio)
            # 视频流置于label中间部分播放
            self.label_screen.setAlignment(Qt.AlignCenter)
            self.label_screen.setPixmap(pixmap)
            if probabilities_array is not None:
                emo_list = []
                # 访问数组中的每个元素
                for i in range(probabilities_array.shape[0]):
                    for j in range(probabilities_array.shape[1]):
                        num = probabilities_array[i, j] * 100
                        emo_list.append(num)

                for i in range(len(emo_list)):
                    self.progresslabel_happy.setProgress(int(emo_list[3]))
                    self.valuelabel_happy.setText(f"{round(emo_list[3], 2)}%")
                    self.progresslabel_sad.setProgress(int(emo_list[5]))
                    self.valuelabel_sad.setText(f"{round(emo_list[5], 2)}%")
                    self.progresslabel_fear.setProgress(int(emo_list[2]))
                    self.valuelabel_fear.setText(f"{round(emo_list[2], 2)}%")
                    self.progresslabel_disgust.setProgress(int(emo_list[1]))
                    self.valuelabel_disgust.setText(f"{round(emo_list[1], 2)}%")
                    self.progresslabel_angry.setProgress(int(emo_list[0]))
                    self.valuelabel_angry.setText(f"{round(emo_list[0], 2)}%")
                    self.progresslabel_surprise.setProgress(int(emo_list[6]))
                    self.valuelabel_surprise.setText(f"{round(emo_list[6], 2)}%")
                    self.progresslabel_tired.setProgress(int(emo_list[7]))
                    self.valuelabel_tired.setText(f"{round(emo_list[7], 2)}%")
                    self.progresslabel_neutral.setProgress(int(emo_list[4]))
                    self.valuelabel_neutral.setText(f"{round(emo_list[4], 2)}%")
                else:
                    pass

    def init_progressbar(self):
        self.progresslabel_happy.setProgress(0)
        self.valuelabel_happy.setText("0.0%")
        self.progresslabel_sad.setProgress(0)
        self.valuelabel_sad.setText("0.0%")
        self.progresslabel_fear.setProgress(0)
        self.valuelabel_fear.setText("0.0%")
        self.progresslabel_disgust.setProgress(0)
        self.valuelabel_disgust.setText("0.0%")
        self.progresslabel_angry.setProgress(0)
        self.valuelabel_angry.setText("0.0%")
        self.progresslabel_surprise.setProgress(0)
        self.valuelabel_surprise.setText("0.0%")
        self.progresslabel_tired.setProgress(0)
        self.valuelabel_tired.setText("0.0%")
        self.progresslabel_neutral.setProgress(0)
        self.valuelabel_neutral.setText("0.0%")

    def enable_rest_spinBox(self, event):
        if self.switchButton_rest_opener.state:
            self.switchButton_rest_opener.state = False
            self.switchButton_Pomodoro_Technique.state = False
            self.switchButton_Pomodoro_Technique.setEnabled(False)
            self.spinBox_Pomodoro_Technique.setEnabled(False)
            self.spinBox_rest_inform.setEnabled(False)
        else:
            self.switchButton_rest_opener.state = True
            self.spinBox_rest_inform.setEnabled(True)
            self.switchButton_Pomodoro_Technique.state = True
            self.switchButton_Pomodoro_Technique.setEnabled(True)
            self.spinBox_Pomodoro_Technique.setEnabled(True)
        self.switchButton_Pomodoro_Technique.update()
        self.switchButton_rest_opener.update()

    def enable_Pomodoro_Technique_spinBox(self, event):
        if self.switchButton_Pomodoro_Technique.state:
            self.switchButton_Pomodoro_Technique.state = False
            self.spinBox_Pomodoro_Technique.setEnabled(False)
        else:
            self.switchButton_Pomodoro_Technique.state = True
            self.spinBox_Pomodoro_Technique.setEnabled(True)
        self.switchButton_Pomodoro_Technique.update()

    def enable_tired_spinBox(self, event):
        if self.switchButton_tired_opener.state:
            self.switchButton_tired_opener.state = False
        else:
            self.switchButton_tired_opener.state = True
        self.switchButton_tired_opener.update()

    def save_settings(self):
        if self.switchButton_rest_opener.state:
            Notification_switch = 'ON'
        else:
            Notification_switch = 'OFF'
        if self.switchButton_Pomodoro_Technique.state:
            Pomodoro_Technique = 'ON'
        else:
            Pomodoro_Technique = 'OFF'
        if self.switchButton_tired_opener.state:
            alert_switch = 'ON'
        else:
            alert_switch = 'OFF'
        if self.radioButton_direct.isChecked():
            Exit = 0
        else:
            Exit = 1

        # 新配置字典
        new_config = {
            'rest reminder': {
                'Notification_switch': Notification_switch,
                'Notice_interval_time': self.spinBox_rest_inform.value(),
                'Pomodoro_Technique': Pomodoro_Technique,
                'Learning_interval_time': self.spinBox_Pomodoro_Technique.value()
            },
            'Exhaustion alert': {
                'alert_switch': alert_switch
            },
            'Exit setting': {
                'Exit': Exit  # 更改退出设置
            },
            'Database': {
                'user': user,
                'password': password
            }
        }

        # 假设设置文件的路径
        file_path = '../asset/settings.txt'

        with open(file_path, 'w') as file:
            for section, settings in new_config.items():
                file.write(f'# {section}\n')
                for key, value in settings.items():
                    file.write(f'{key}={value}\n')
                file.write('\n')

    def insertRecord(self):
        if sum(emotion_total_duration.values()) != 0:
            conn = getDatabaseConnection()
            cursor = conn.cursor()
            sql = (
                "INSERT INTO `emotions_duration` (`angry`, `disgust`, `fear`, `happy`, `neutral`, `sad`, `surprise`, `tired`) "
                "VALUES (%s, %s, %s, %s, %s, %s, %s, %s)")
            try:
                # 使用字典的values()方法获取所有值，并转换为元组
                values_tuple = tuple(emotion_total_duration.values())
                cursor.execute(sql, values_tuple)
                conn.commit()  # 确保提交事务以保存更改
            except Exception as e:
                conn.rollback()

    def showTotalTime(self):
        last_time = []

        for emotion, duration in emotion_total_duration.items():
            last_time.append(duration)

        # 创建并显示柱状图弹出窗口
        dialog = ChartDialog(list(emotion_total_duration.values()), list(emotion_labels.values()))
        dialog.exec_()

    def closeEvent(self, event):
        # 重写关闭事件
        if self.radioButton_direct.isChecked():
            # 如果 RadioButton 被选中，退出程序
            self.insertRecord()
            QApplication.instance().quit()
        else:
            event.ignore()  # 忽略关闭事件
            self.hide()  # 隐藏窗口
            # self.tray_icon.showMessage('应用已最小化', '应用已最小化到系统托盘。')

    def iconActivated(self, reason):
        # 当系统托盘图标被激活（例如单击）时调用
        if reason in (QSystemTrayIcon.Trigger, QSystemTrayIcon.DoubleClick):
            self.showNormal()  # 显示窗口

    def quit(self):
        self.insertRecord()
        QApplication.quit()


"""
休息提醒部分
"""


def tip1():  # 疲惫持续时间超过2秒自动调用，在检测窗口中提示，可手动关闭
    root = tkinter.Tk()
    root.withdraw()
    messagebox.showinfo('提示', '我发现你有点困了，休息一下吧!')


def tip2():
    root = tkinter.Tk()
    root.withdraw()
    messagebox.showinfo('提示', '使用电脑已经一段时间了，休息一会吧')


def tip3():
    root = tkinter.Tk()
    root.withdraw()
    messagebox.showinfo('提示', '休息时间到了，回去工作吧')


def info_mess(set_time, open_time, flag):
    if open_time >= set_time:
        if not flag:
            return False
        else:
            tip2()
            return True
    else:
        return False


def tip(last_time):  # 一段时间后的综合提醒
    timex = max(last_time)
    maxindex = last_time.index(timex)
    root = tkinter.Tk()
    root.withdraw()
    if maxindex == 0:
        messagebox.showinfo('提示', '不要生气了，放轻松!')
    elif maxindex == 1:
        messagebox.showinfo('提示', '不要厌恶，保持乐观!')
    elif maxindex == 2:
        messagebox.showinfo('提示', '不要害怕，保持自信!')
    elif maxindex == 3:
        messagebox.showinfo('提示', '这段时间你很开心!')
    elif maxindex == 4:
        messagebox.showinfo('提示', '这段时间很自然!内心平静!')
    elif maxindex == 5:
        messagebox.showinfo('提示', '不要难过，开心点!')
    elif maxindex == 6:
        messagebox.showinfo('提示', '这段时间时常惊喜，有什么事值得分享!')
    else:
        messagebox.showinfo('提示', '这段时间相对较困，找个合适的时间休息一下吧!')


def initDatabase():
    import pymysql
    conn = pymysql.connect(host="127.0.0.1", user=user, password=password,
                           charset='utf8')
    cursor = conn.cursor()
    sqlCreateDatabase = "CREATE DATABASE IF NOT EXISTS `facial-emotions`"
    try:
        cursor.execute(sqlCreateDatabase)
        conn.commit()  # 确保提交事务以保存更改
    except Exception as e:
        conn.rollback()

    conn.close()
    cursor.close()


def initTable():
    conn = getDatabaseConnection()
    cursor = conn.cursor()
    sqlCreateTable = ("CREATE TABLE IF NOT EXISTS `emotions_duration` ("
                      "`id` INT AUTO_INCREMENT PRIMARY KEY,"
                      "`angry` INT NOT NULL,"
                      "`disgust` INT NOT NULL,"
                      "`fear` INT NOT NULL,"
                      "`happy` INT NOT NULL,"
                      "`neutral` INT NOT NULL,"
                      "`sad` INT NOT NULL,"
                      "`surprise` INT NOT NULL,"
                      "`tired` INT NOT NULL,"
                      "`rectime` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP)")

    try:
        cursor.execute(sqlCreateTable)
        conn.commit()  # 确保提交事务以保存更改
    except Exception as e:
        conn.rollback()

    conn.close()
    cursor.close()


def check_database_exists():
    import pymysql
    from tkinter import messagebox
    import tkinter as tk

    try:
        conn = pymysql.connect(host="127.0.0.1", user=user, password=password, charset='utf8')
        cursor = conn.cursor()
        cursor.execute("SHOW DATABASES LIKE %s", ("facial-emotions",))
        result = cursor.fetchone()
        return result is not None
    except pymysql.OperationalError as e:
        # 初始化Tkinter窗口，但不显示它
        root = tk.Tk()
        root.withdraw()
        # 弹出错误消息框
        messagebox.showerror("数据库连接失败", f"请检查数据库用户名及密码，错误信息：{e}")
        return -1  # 返回False，因为无法验证数据库是否存在
    finally:
        # 确保无论如何都关闭连接和游标
        if 'conn' in locals() and conn:
            conn.close()
        if 'cursor' in locals() and cursor:
            cursor.close()


def read_credentials():
    file_path = '../asset/settings.txt'
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line in lines:
            if line.startswith('user='):
                user = line.strip().split('=')[1]
            elif line.startswith('password='):
                password = line.strip().split('=')[1]
    return user, password


user = ""
password = ""

import sys
from PyQt5.QtWidgets import QApplication

if __name__ == '__main__':
    user, password = read_credentials()
    check_database = check_database_exists()
    if check_database == True:
        pass
    elif check_database == -1:
        sys.exit(-1)
    else:
        initDatabase()
        initTable()
    app = QApplication(sys.argv)
    ui = MyWindow()  # 这是类函数的名称
    ui.setWindowTitle("电脑用户状态监测系统")
    ui.show()
    sys.exit(app.exec_())
